"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSnapExecutor = void 0;
const providers_1 = require("@metamask/providers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const openrpc_json_1 = __importDefault(require("../openrpc.json"));
const openrpc_guard_1 = require("../__GENERATED__/openrpc.guard");
const endowments_1 = require("./endowments");
const globalObject_1 = require("./globalObject");
const rpcMethods_1 = require("./rpcMethods");
const sortParams_1 = require("./sortParams");
const fallbackError = {
    code: eth_rpc_errors_1.errorCodes.rpc.internal,
    message: 'Execution Environment Error',
};
class BaseSnapExecutor {
    constructor(commandStream, rpcStream) {
        this.snapData = new Map();
        this.commandStream = commandStream;
        this.commandStream.on('data', this.onCommandRequest.bind(this));
        this.rpcStream = rpcStream;
        this.methods = (0, rpcMethods_1.rpcMethods)(this.startSnap.bind(this), (target, origin, request) => {
            const data = this.snapData.get(target);
            if (data?.exports?.onRpcRequest === undefined) {
                throw new Error(`No onRpcRequest handler exported for snap "${target}`);
            }
            // We're capturing the handler in case someone modifies the data object before the call
            const handler = data.exports.onRpcRequest;
            return this.executeInSnapContext(target, () => handler({ origin, request }));
        }, this.onTerminate.bind(this));
    }
    errorHandler(error, data = {}) {
        const serializedError = (0, eth_rpc_errors_1.serializeError)(error, {
            fallbackError,
            shouldIncludeStack: true,
        });
        this.notify({
            error: {
                ...serializedError,
                data: {
                    ...data,
                    stack: serializedError.stack,
                },
            },
        });
    }
    async onCommandRequest(message) {
        if (!(0, openrpc_guard_1.isJsonRpcRequest)(message)) {
            throw new Error('Command stream received a non Json Rpc Request');
        }
        const { id, method, params } = message;
        if (id === undefined) {
            throw new Error('Notifications not supported');
        }
        if (method === 'rpc.discover') {
            this.respond(id, {
                result: openrpc_json_1.default,
            });
            return;
        }
        const methodObject = openrpc_json_1.default.methods.find((m) => m.name === method);
        if (!methodObject || !this.methods[method]) {
            this.respond(id, {
                error: eth_rpc_errors_1.ethErrors.rpc
                    .methodNotFound({
                    data: {
                        method,
                    },
                })
                    .serialize(),
            });
            return;
        }
        // support params by-name and by-position
        const paramsAsArray = (0, sortParams_1.sortParamKeys)(methodObject, params);
        try {
            const result = await this.methods[method](...paramsAsArray);
            this.respond(id, { result });
        }
        catch (e) {
            this.respond(id, {
                error: (0, eth_rpc_errors_1.serializeError)(e, {
                    fallbackError,
                }),
            });
        }
    }
    notify(requestObject) {
        this.commandStream.write({
            ...requestObject,
            jsonrpc: '2.0',
        });
    }
    respond(id, responseObj) {
        this.commandStream.write({
            ...responseObj,
            id,
            jsonrpc: '2.0',
        });
    }
    /**
     * Attempts to evaluate a snap in SES.
     * Generates the APIs for the snap. May throw on error.
     *
     * @param {string} snapName - The name of the snap.
     * @param {Array<string>} approvedPermissions - The snap's approved permissions.
     * Should always be a value returned from the permissions controller.
     * @param {string} sourceCode - The source code of the snap, in IIFE format.
     * @param {Array} endowments - An array of the names of the endowments.
     */
    async startSnap(snapName, sourceCode, _endowments) {
        console.log(`starting snap '${snapName}' in worker`);
        if (this.snapPromiseErrorHandler) {
            globalObject_1.rootRealmGlobal.removeEventListener('unhandledrejection', this.snapPromiseErrorHandler);
        }
        if (this.snapErrorHandler) {
            globalObject_1.rootRealmGlobal.removeEventListener('error', this.snapErrorHandler);
        }
        this.snapErrorHandler = (error) => {
            this.errorHandler(error.error, { snapName });
        };
        this.snapPromiseErrorHandler = (error) => {
            this.errorHandler(error.reason, { snapName });
        };
        const wallet = this.createSnapProvider();
        // We specifically use any type because the Snap can modify the object any way they want
        const snapModule = { exports: {} };
        try {
            const { endowments, teardown: endowmentTeardown } = (0, endowments_1.createEndowments)(wallet, _endowments);
            // !!! Ensure that this is the only place the data is being set.
            // Other methods access the object value and mutate its properties.
            this.snapData.set(snapName, {
                idleTeardown: endowmentTeardown,
                runningEvaluations: new Set(),
                exports: {},
            });
            globalObject_1.rootRealmGlobal.addEventListener('unhandledrejection', this.snapPromiseErrorHandler);
            globalObject_1.rootRealmGlobal.addEventListener('error', this.snapErrorHandler);
            const compartment = new Compartment({
                ...endowments,
                module: snapModule,
                exports: snapModule.exports,
                window: { ...endowments },
                self: { ...endowments },
            });
            await this.executeInSnapContext(snapName, () => {
                compartment.evaluate(sourceCode);
                this.registerSnapExports(snapName, snapModule);
            });
        }
        catch (err) {
            this.removeSnap(snapName);
            throw new Error(`Error while running snap '${snapName}': ${err.message}`);
        }
    }
    /**
     * Cancels all running evaluations of all snaps and clears all snap data.
     * **NOTE:** Should only be called in response to the `terminate` RPC command.
     */
    onTerminate() {
        // `stop()` tears down snap endowments.
        // Teardown will also be run for each snap as soon as there are
        // no more running evaluations for that snap.
        this.snapData.forEach((data) => data.runningEvaluations.forEach((evaluation) => evaluation.stop()));
        this.snapData.clear();
    }
    registerSnapExports(snapName, snapModule) {
        if (typeof snapModule?.exports?.onRpcRequest === 'function') {
            const data = this.snapData.get(snapName);
            // Somebody deleted the Snap before we could register
            if (data !== undefined) {
                console.log('Worker: Registering RPC message handler', snapModule.exports.onRpcRequest);
                data.exports = {
                    ...data.exports,
                    onRpcRequest: snapModule.exports.onRpcRequest,
                };
            }
        }
    }
    /**
     * Creates a hardened snap provider object (i.e. globalThis.wallet), and returns it.
     */
    createSnapProvider() {
        return new providers_1.MetaMaskInpageProvider(this.rpcStream, {
            shouldSendMetadata: false,
        });
    }
    /**
     * Removes the snap with the given name.
     */
    removeSnap(snapName) {
        this.snapData.delete(snapName);
    }
    /**
     * Calls the specified executor function in the context of the specified snap.
     * Essentially, this means that the operation performed by the executor is
     * counted as an evaluation of the specified snap. When the count of running
     * evaluations of a snap reaches zero, its endowments are torn down.
     *
     * @param snapName - The name of the snap whose context to execute in.
     * @param executor - The function that will be executed in the snap's context.
     * @returns The executor's return value.
     * @template Result - The return value of the executor.
     */
    async executeInSnapContext(snapName, executor) {
        const data = this.snapData.get(snapName);
        if (data === undefined) {
            throw new Error(`Tried to execute in context of unknown snap: "${snapName}".`);
        }
        let stop;
        const stopPromise = new Promise((_, reject) => (stop = () => reject(
        // TODO(rekmarks): Specify / standardize error code for this case.
        eth_rpc_errors_1.ethErrors.rpc.internal(`The snap "${snapName}" has been terminated during execution.`))));
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const evaluationData = { stop: stop };
        try {
            data.runningEvaluations.add(evaluationData);
            // Notice that we have to await this executor.
            // If we didn't, we would decrease the amount of running evaluations
            // before the promise actually resolves
            return await Promise.race([executor(), stopPromise]);
        }
        finally {
            data.runningEvaluations.delete(evaluationData);
            if (data.runningEvaluations.size === 0) {
                data.idleTeardown();
            }
        }
    }
}
exports.BaseSnapExecutor = BaseSnapExecutor;
//# sourceMappingURL=BaseSnapExecutor.js.map