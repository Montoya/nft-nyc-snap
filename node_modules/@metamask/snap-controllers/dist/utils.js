"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.withTimeout = exports.hasTimedOut = exports.delay = exports.setDiff = void 0;
/**
 * Takes two objects and does a Set Difference of them.
 * Set Difference is generally defined as follows:
 * ```
 * 𝑥 ∈ A ∖ B ⟺ 𝑥 ∈ A ∧ 𝑥 ∉ B
 * ```
 * Meaning that the returned object contains all properties of A expect those that also
 * appear in B. Notice that properties that appear in B, but not in A, have no effect.
 *
 * @see [Set Difference]{@link https://proofwiki.org/wiki/Definition:Set_Difference}
 *
 * @param objectA The object on which the difference is being calculated
 * @param objectB The object whose properties will be removed from objectA
 * @returns objectA without properties from objectB
 */
function setDiff(objectA, objectB) {
    return Object.entries(objectA).reduce((acc, [key, value]) => {
        if (!(key in objectB)) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
exports.setDiff = setDiff;
/**
 * A Promise that delays it's return for a given amount of milliseconds.
 *
 * @param ms - Milliseconds to delay the execution for.
 * @param result - The result to return from the Promise after delay.
 * @returns void if no result provided, result otherwise.
 * @template Result - The `result`.
 */
function delay(ms, result) {
    let timeoutHandle;
    let rejectFunc;
    const promise = new Promise((resolve, reject) => {
        timeoutHandle = setTimeout(() => {
            timeoutHandle = undefined;
            result === undefined ? resolve() : resolve(result);
        }, ms);
        rejectFunc = reject;
    });
    promise.cancel = () => {
        if (timeoutHandle !== undefined) {
            clearTimeout(timeoutHandle);
            rejectFunc('The delay has been canceled.');
        }
    };
    return promise;
}
exports.delay = delay;
/*
 * We use a Symbol instead of rejecting the promise so that Errors thrown
 * by the main promise will propagate.
 */
exports.hasTimedOut = Symbol('Used to check if the requested promise has timeout (see withTimeout)');
/**
 * Executes the given Promise, if after ms milliseconds the Promise doesn't
 * settle, we return earlier.
 *
 * **NOTE:** The given Promise is not cancelled or interrupted, and will continue
 *          to execute uninterrupted. We will just discard its result if it does
 *          not complete before the timeout.
 *
 * @param promise - The promise that you want to execute.
 * @param ms - Amout of milliseconds to wait before finishing early.
 * @returns The resolved `PromiseValue`, or the hasTimedOut symbol if
 * returning early.
 * @template PromiseValue - The value of the Promise.
 */
async function withTimeout(promise, ms) {
    const delayPromise = delay(ms, exports.hasTimedOut);
    try {
        return await Promise.race([promise, delayPromise]);
    }
    finally {
        delayPromise.cancel();
    }
}
exports.withTimeout = withTimeout;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforces exhaustivity during compile-time
 *
 * @example
 * ```
 * const snapPrefix = snapIdToSnapPrefix(snapId);
 * switch (snapPrefix) {
 *   case SnapIdPrefixes.local:
 *     ...
 *   case SnapIdPrefixes.npm:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 *
 * @param _ The object on which the switch is being operated
 */
/* istanbul ignore next */
function assertExhaustive(_) {
    throw new Error('Invalid branch reached. Should be detected during compilation');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=utils.js.map